import EZproblem as ez
from random import randint, choice

# This example implements subtasks described in https://codebreaker.xyz/problem/bracketex

"""
The creator.py file implements the functions that generate testcases,
  and tell EZproblem about subtasks and how many testcases to generate.

In every creator.py file, the global scope must have:
- problem: the ez.Problem object which represents your problem
- solver: a string, the filename of your solver executable (the compilation product)

The order of subtasks and testcase types in this file will be the same as
  in the allocation.
"""

problem = ez.Problem("bracketex") # The string provided is what you want EZproblem to call your problem.
solver = "solver"

# These two functions arent related to EZproblem.
def valid_brackets(length, brackets = ["[]","()","{}"]):
	"""Function which generates valid bracket sequence of specified length"""
	assert(length % 2 == 0)
	result = ""
	stack = []
	while length - len(result) > len(stack):
		if len(stack) > 0 and choice([True, False]):
			# Close a set
			result += stack.pop()
		else:
			bracket = choice(brackets)
			result += bracket[0]
			stack.append(bracket[1])
	# Close all sets
	while len(stack) > 0:
		result += stack.pop()
	return result

def random_brackets(length, brackets = "[](){}"):
	result = ""
	for _ in range(length):
		result += choice(brackets)
	return result

# Adds a new subtask
# Subtask 1 (10 points): 1 ≤ L ≤ 4.
subtask_1 = problem.new_subtask(ez.cbr_naming(1, 10)) # Subtask #1 (10 points)

# Adds 5 testcases to subtask 1, which EZproblem will call "Valid"
# It will be called 5 times to produce 5 cases.
# The @decorator registers the test case generator to the subtask. 
@subtask_1.testcases(5, "Valid")
def factory(i): 
	# Function which generates one such testcase, returns it as a string
	return "4\n" + valid_brackets(4)

# Adds another 10 testcases to subtask 1, which EZproblem will call "Random"
@subtask_1.testcases(10, "Random")
def factory(i): 
	length = 4
	return f"{length}\n" + random_brackets(length)

# Troll testcase that is still valid
@subtask_1.testcases(3, "Trolling")
def factory(i): 
	length = 1
	return f"{length}\n" + random_brackets(length)

# Add another subtask
# Subtask 2 (30 points): 1 ≤ L ≤ 1000.
subtask_2 = problem.new_subtask(ez.cbr_naming(2, 30)) # Subtask #2 (30 points)

@subtask_2.testcases(5, "Valid")
def factory(i): 
	length = 2 * randint(900//2, 1000//2)
	return f"{length}\n" + valid_brackets(length)

###### The rest of this file follows the same patterns.
###### Skip to the section header below

@subtask_2.testcases(15, "Random")
def factory(i): 
	length = 2 * randint(900//2, 1000//2)
	return f"{length}\n" + random_brackets(length)

@subtask_2.testcases(3, "Odd length")
def factory(i): 
	length = 2 * randint(900//2, 1000//2) - 1 
	return f"{length}\n" + random_brackets(length)

subtask_3 = problem.new_subtask(ez.cbr_naming(3, 20)) # Subtask #3 (20 points)

@subtask_3.testcases(5, "Valid")
def factory(i): 
	length = 2 * randint(90000//2, 100000//2)
	return f"{length}\n" + valid_brackets(length, brackets = ["()"])

@subtask_3.testcases(15, "Random")
def factory(i): 
	length = 2 * randint(90000//2, 100000//2)
	return f"{length}\n" + random_brackets(length, brackets = "()")

@subtask_3.testcases(3, "Odd length")
def factory(i): 
	length = 2 * randint(90000//2, 100000//2) - 1
	return f"{length}\n" + random_brackets(length, brackets = "()")

subtask_4 = problem.new_subtask(ez.cbr_naming(4, 40)) # Subtask #4 (40 points)

@subtask_4.testcases(5, "Valid")
def factory(i): 
	length = 2 * randint(90000//2, 100000//2)
	return f"{length}\n" + valid_brackets(length)

@subtask_4.testcases(15, "Random")
def factory(i): 
	length = 2 * randint(90000//2, 100000//2)
	return f"{length}\n" + random_brackets(length)

@subtask_4.testcases(3, "Odd length")
def factory(i): 
	length = 2 * randint(90000//2, 100000//2) - 1
	return f"{length}\n" + random_brackets(length)

###### HERE

# Subtask 5, sample testcases
subtask_5 = problem.new_subtask(ez.cbr_naming(5, 0)) 

@subtask_5.testcases(3, "Sample testcases")
def factory(i): 
	# Notice that all the factory functions take an argument i
	# That argument is an integer, the number of testcases already generated by this factory.
	# So the first subtask generated by this function will get i=0, second gets i=1 etc.
	if i == 0:
		return "6\n([]{})"
	elif i == 1:
		return "8\n(())((()"
	elif i == 2:
		return "6\n([}{])"
	else:
		raise ValueError("Too many sample testcase subtasks are being generated!")